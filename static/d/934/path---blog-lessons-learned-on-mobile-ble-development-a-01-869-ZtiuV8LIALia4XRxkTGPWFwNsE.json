{"data":{"site":{"siteMetadata":{"title":"Agus Aliaga","author":"Agustín Aliaga"}},"markdownRemark":{"id":"6c0d58fb-2d57-585c-9afb-7d53e307cd02","excerpt":"I’ve spent a couple of months working in a project where BLE support is critical\nfor the client’s business as an android developer, side-by…","html":"<p><img src=\"https://cdn-images-1.medium.com/max/800/1*5poGnoitx0bH7zTn29LxcA.png\"></p>\n<p>I’ve spent a couple of months working in a project where BLE support is critical\nfor the client’s business as an android developer, side-by-side with an iOS\ndeveloper. It was my first experience with BLE, and I have learned a couple of\nthings that I want to share with anyone that’s going in the same path.</p>\n<h3>Classic Bluetooth vs Bluetooth Low Energy</h3>\n<p>This is the very first thing you will ask yourself if, like me, you are not\nfamiliar with this technology. Basically, they are wireless communication\ntechnologies that allow devices to transmit data between them. One of the\ndevices will take the “central” role, and the other one the “peripheral” mode.\nThe <strong>Bluetooth 4.0</strong> standard allows operating in both or any of these two\nimplementations. Here are some of the differences between them:</p>\n<h4>Classic Bluetooth</h4>\n<ul>\n<li>Created to transfer data wirelessly between short-range devices.</li>\n<li>It can transfer a big amount of data, but it consumes much more energy to do so.</li>\n<li>Common use cases: Audio streaming to headsets, file transfers, wireless\nspeakers, connecting your smartphone to a car stereo system, etc.</li>\n<li>Engineering details: it operates at frequencies between 2402 and 2480 MHz, or\n2400 and 2483.5 MHz including <a href=\"https://en.wikipedia.org/wiki/Guard_band\">guard\nbands</a> 2 MHz wide at the bottom end\nand 3.5 MHz wide at the top.</li>\n</ul>\n<h4>Bluetooth Low Energy</h4>\n<ul>\n<li>Also called “Bluetooth Smart” by the industry, it was introduced in Bluetooth\n4.0.</li>\n<li>It’s design to drastically reduce power consumption, and to transfer small\namounts of data.</li>\n<li>Common use cases: Especially interesting in the IoT world, it can be used in\naccessories like blood pressure monitors, glucose monitors, heart rate monitor,\nindustrial monitoring sensors, proximity sensors (read about iBeacons), etc.</li>\n<li>Engineering details: Bluetooth Smart technology operates in the same spectrum\nrange (the 2.400–2.4835 GHz ISM band) as Classic Bluetooth technology, but uses\na different set of channels. Instead of the Classic Bluetooth 79 1-MHz channels,\nBluetooth Smart has 40 2-MHz channels.</li>\n</ul>\n<h3>Some details on BLE</h3>\n<p>BLE has been supported in iPhones since iOS 5, and in Android since version 4.3.\nInformation in BLE peripherals is displayed in something we call\n“Characteristics”. Each characteristic contains a small piece of data.\nCharacteristics are the main point that you will interact with your BLE\nperipheral. For example, one characteristic may contain the devices’s battery\nlevel data. Characteristics are contained in what we call a “Service”. Both\nservices and characteristics are identified by a UUID. So, a BLE peripheral\ncontains one or more services, and each service one or more characteristics. You\ncan read values, set values and subscribe to receive value updates of the\ncharacteristics you want.</p>\n<p>Also, a **BLE peripheral device can only be connected to one central device at a\ntime. **As soon as a peripheral connects to a central device, it will stop\nadvertising itself and other devices will no longer be able to see it or connect\nto it until the existing connection ends.</p>\n<h3>Lessons learned</h3>\n<ul>\n<li>If you don’t need to transfer huge amounts of data, go with BLE instead of\nclassic Bluetooth.</li>\n</ul>\n<h4>Android</h4>\n<ul>\n<li>Android BLE support is relatively new, it was introduced in version 4.3 and it\nuses scanning methods that later got deprecated. In version 4.4 there are still\na couple of critical bugs. For instance, if you try to perform a scan,\nspecifying a filter by Service UUID (devices that expose that service) it might\nnot work at all. The 4.4 android platform is full of Bluetooth bugs especially\nin Nexus devices, read more about this\n<a href=\"https://code.google.com/p/android/issues/detail?id=63056\">here</a>. I’d recommend\nstaying away from these android versions and start clean from Android 5\n(Lollipop) or newer if you don’t want to deal with all these platform bugs.</li>\n<li>Android fragmentation is horribly bad. Each manufacturer sets different hardware\nfor each smartphone and it is a big deal for BLE apps. For instance if you’re\nplanning on performing some kind of operation based on signal strength\nmeasurement (RSSI), you should know that different smartphones will receive\ndifferent values of signal strength even if they’re at the same distance of the\nperipheral. I’d recommend trying to define a finite spectrum of devices you’re\ntargeting your app.</li>\n<li>Android lower level API is not well documented. Yes, you can go to <a href=\"https://developer.android.com/guide/topics/connectivity/bluetooth-le.html\">the official\ndocs</a>\nand setup your ideal code to support BLE transactions. The documentations on\nthis side are ok. The real problems in a lower level, when the device notifies\nyour app that there has been some kind of error, within the\n“<a href=\"https://developer.android.com/reference/android/bluetooth/BluetoothGattCallback.html#onConnectionStateChange(android.bluetooth.BluetoothGatt,%0Aint,%20int)\">onConnectionStateChange(BluetoothGatt gatt, int status, int\nnewState)</a>” method. Sometimes you’ll get weird status codes like 133, 19, etc.\nthat are not documented at all. Sometimes they are related to hardware issues,\nconnectivity issues, specific hardware in some devices, and sometimes you really\ncan’t be sure what it is. All these things make BLE development a little\nfrustrating in Android.</li>\n<li>Google lets you fully control the Bluetooth service status of the device (you\ncan turn it on or off). If you use this the wrong way, the user will see it as\ninvasive and will most likely uninstall the app. However, this feature is\nespecially useful if your peripheral will change its Services or Characteristics\nat any time. Why would you need to restart the smartphone’s bluetooth service ?\nWell, in this particular case, if the peripheral changes its characteristics for\nany reason, Android will not be able to see the changes. Services and\nCharacteristics are heavily stored in some kind of caché memory, and only if you\nrestart the service you’ll see the changes reflected on your app. You could also\nuse reflection for this, but I wouldn’t recommend it.</li>\n<li>You can setup a background connection, or value-reading process within a classic\nAndroid Service with no problems at all.</li>\n</ul>\n<h4>iOS</h4>\n<p>Even though I’m not an iOS developer, I’m learning this technology and I can\nalso mention a couple of things that I got from my project.</p>\n<ul>\n<li>As I said before, Android lets you run a task inside a Service such as scanning\nand connecting to a BLE peripheral. In contrast, Apple does not let iOS\ndevelopers to run just anything in background state, but only specific features\nsuch as “playing audio”, “location updates”, “background fetch”, “BLE\noperations” and some others. All these features are disabled by default and\nyou’ll have to enable them in XCode manually. The iOS background execution mode\nis much more restricted than foreground mode in a way that you’re app will\nmostly be reacting to external events, instead of initiating transactions.\nApple’s documentation specifies that when your app is in background mode, it\nwill still receive peripheral updates, but should not take more than 10 seconds\nto process this data. You should really do further research on this if you’re\nplanning on building an iOS app with background BLE support.</li>\n<li>Since Obj-C / Swift compile to a lower level object code (machine-level code)\nthan Java does (byte-code), you can expect some features to run slightly faster,\nsuch as Characteristic value reading or writing. I’m talking about a difference\nof few milliseconds. So unless you’re planning on transferring a <strong>lot</strong> of data\nthrough bluetooth, this will not represent a problem to you.</li>\n</ul>\n<h3>Conclusion</h3>\n<p>Developing mobile apps with BLE support is not an easy task, but it is a\n<strong>possible</strong> task. Try to really understand how this technology works before you\nstart coding. This also means you should know what kind of limitations you’ll\nface within Android and iOS, so you get an idea about the technical feasibility\nof your product. If you know the rules, you’ll be able to build a complex (and\nawesome) bluetooth-capable app.</p>","frontmatter":{"title":"Lessons learned from building a mobile app with Bluetooth Low Energy support","date":"March 17, 2017"}}},"pageContext":{"slug":"/blog/lessons-learned-on-mobile-ble-development/","previous":{"fields":{"slug":"/blog/common-android-scenarios-with-and-without-dependencies-part-1-rest/","type":"blog"},"frontmatter":{"title":"Common Android scenarios with and without third-party dependencies, part 1: REST Client"}},"next":{"fields":{"slug":"/blog/common-android-scenarios-with-and-without-dependencies-part-2-layouts/","type":"blog"},"frontmatter":{"title":"Common Android scenarios with and without third-party dependencies, part 2: Layouts"}}}}