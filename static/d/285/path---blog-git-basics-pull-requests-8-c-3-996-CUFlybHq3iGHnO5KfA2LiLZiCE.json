{"data":{"site":{"siteMetadata":{"title":"Agus Aliaga","author":"Agustín Aliaga"}},"markdownRemark":{"id":"14c814c6-3041-5637-852e-a0376e39081e","excerpt":"Git is a powerful version-control system designed to make software development\ncollaboration easy. It can be used for personal (single…","html":"<p><img src=\"https://cdn-images-1.medium.com/max/800/1*2nuioCxg2o7II-XfLLZ3hQ.jpeg\"></p>\n<p>Git is a powerful version-control system designed to make software development\ncollaboration easy. It can be used for personal (single contributor)\nrepositories, but it really stands out in projects where multiple developers\nmodify the same codebase every day. Multiple branching models can be adopted.\nHowever, in most cases, a Pull Request (PR) will be created when a bug fix or a\nnew feature is ready to be merged into the main branch. The PR itself is an\nattempt to merge specific changes from one branch to another. Let’s explore the\nPull Request workflow in detail.</p>\n<h3>PR Creation</h3>\n<p>Whenever a PR is created, the following good practices should be considered:</p>\n<ul>\n<li><strong>Adding a helpful description to the PR</strong> that answers the following questions:\nWhat is the requirement or bug? Is there a link to the issue (e.g. on JIRA)? How\ndoes your code fix it? Is there anything else the reviewer should take into\nconsideration?</li>\n<li>Making <strong>small, consistent and logical PRs</strong>: We want our PR to be merged as\nsoon as possible. Imagine how hard it would be to review hundreds of file\nchanges at the same time. If this happens, it is likely that the reviewer won’t\neven have the time to do it properly. So try to keep it simple and concise.</li>\n<li>Making sure the PR’s metadata has been set. For example, by assigning the\nreviewer (to trigger a notification), setting the assignees, adding a label (if\nneeded), etc.</li>\n<li>Configuring the repo’s branching security settings to keep developers away from\nself-merging their PRs or pushing to a shared base branch. I recommend enforcing\nGithub’s branching security settings. When a large team of devs is collaborating\nin the same repo, accidents may happen. A single miss click in a “merge” button\ncan cause terrible headaches. Protecting important branches is something I’d\nadvise most of the times.</li>\n<li>Avoiding submissions that include unresolved conflicts. Fixing those conflicts\nshouldn’t be a reviewer’s responsibility. PR creators should dedicate time to\nsolve them either by using Github’s conflict resolution tool (when it’s simple\nenough) or by using your favorite diff tool locally. You can achieve this by\npulling the base branch and merging it into your feature branch. After you\npushed it to the remote repo, the PR will automatically update.</li>\n</ul>\n<h3>Automated tests</h3>\n<p>If a Continuous Integration system (such as Jenkins, Travis, or CircleCI) is set\nup, a bunch of hooks can be configured to run unit tests on PR creation. This\nwill allow the team to detect and catch bugs rapidly, as well as prevent\nconflictive code from being merged. This is a long topic that requires its own\nblog post, so I’ll just move on to the following stages.</p>\n<h3>Code Review</h3>\n<p>After everything related to the creation of the PR is dealt with and the CI\ntests passed, it is time for a code review. Projects tend to have tight\ndeadlines, which sometimes makes code reviews seem like a waste of time by other\nteam members or external agents. Ironically, code revisions actually help to\nincrease productivity and reduce rework because we avoid bad practices in our\ncode and share knowledge between contributors.</p>\n<p>Some benefits of implementing code reviews are:</p>\n<ul>\n<li>Less experienced devs get to learn from their mistakes.</li>\n<li>Experienced developers consolidate their knowledge as they teach others.</li>\n<li>A high-quality codebase is ensured.</li>\n</ul>\n<h3>Humility: a soft skill that matters</h3>\n<p>Sometimes, as work starts to accumulate and things get tense, some engineers\ntend to become less aware of their attitude towards their peers. It is always\nimportant to avoid egocentric behavior, listen to our co-workers, and moderate\nour communication when reviewing other people’s work. If we write a PR review in\na disrespectful/arrogant manner, we could be damaging the team’s confidence and\nthe work environment.</p>\n<h3>The “reviewer” role</h3>\n<p>Ideally, teams should implement peer reviews. This means that anyone should have\nthe required experience and skills to review other’s code. In practice,\ncollaborators regularly have different levels of experience on both the\ntechnology used for the project and the codebase itself, including its set-up,\narchitecture, code styling, deployment, etc. In this case, experienced\ndevelopers should be conducting the reviews and newer team members should be\nincluded progressively as they get comfortable with the project.</p>\n<h3>Merging the PR</h3>\n<p>After the PR was approved, it’s time to merge it. We have a couple of options to\ndo so. Let’s explore them:</p>\n<ul>\n<li><strong>Create a Merge Commit (default):</strong> This option will merge all the commits from\nthe feature branch <strong>plus a new merge commit</strong>. This is the safest way to\nperform the merge, since it is a “non-destructive” operation. The downside of\nusing this option is that since it creates a merge commit to tying together the\nhistory of both branches, it pollutes your history tree with multiple\n“irrelevant commits”.</li>\n<li><strong>Squash and Merge:</strong> This option will “squash” all the commits into a single\none. If the PR includes a lot of commits, this could be the way to go. It will\nmake your history tree much cleaner and easier to read in your base branch.\nNevertheless, you will lose granularity due to the bigger size of the resulting\ncommit.</li>\n<li><strong>Rebase and Merge:</strong> The “rebase” operation is another way to combine commits\nfrom two different branches. This will put your feature branch commits on top of\nyour base branch’s latest commit, and effectively rewrite the commit history.\nAfter this, it will perform a fast-forward merge, making it look like all the\nwork was done on the base branch. This is extremely dangerous when the rewritten\nbranch is public and shared with other team members. Generally,** the rule of\nthumb is to keep rebasing operations for private-only branches.**</li>\n</ul>\n<p><strong>Originally published at <a href=\"https://santexgroup.com/blog/git-basics-pull-requests/\">santexgroup.com</a></strong> on\nOctober 10, 2018.</p>","frontmatter":{"title":"Git Basics: Pull Requests","date":"October 13, 2018"}}},"pageContext":{"slug":"/blog/git-basics-pull-requests/","previous":{"fields":{"slug":"/blog/js-vs-java-part-1/","type":"blog"},"frontmatter":{"title":"JS vs Java: Part 1 — scope, closures, global context, this, and undefined"}},"next":{"fields":{"slug":"/blog/js-vs-java-part-2/","type":"blog"},"frontmatter":{"title":"JS vs Java: Part 2 — Object creation, inheritance, encapsulation, and modules"}}}}