{"data":{"site":{"siteMetadata":{"title":"Blogging!","author":"Agustín Aliaga"}},"markdownRemark":{"id":"9a576ed6-3bf6-57d6-91f5-bd32d477e5c5","excerpt":"In this tutorial series I’ll be creating a very simple app called “GiphyTrends”\nthat will demonstrate how to use some third-party libraries…","html":"<p>In this tutorial series I’ll be creating a very simple app called “GiphyTrends”\nthat will demonstrate how to use some third-party libraries. The libraries I\nchose are the ones that I found extremely useful in previous projects, and the\napp itself will be really simple so we can focus in showing the strong points of\nthem. Our app will display the trending GIFs of “Giphy”. I’m using this service\njust because at the moment of writing this tutorial it has an open API that\nwe’ll be using to retrieve data from. For each tutorial we’ll be comparing one\n“Android SDK” solution to a “third-party” one. In other words, we’ll compare\nboth implementations: with and without the library itself. It doesn’t mean that\nthese are the only ways to achieve our goals, but rather two different\napproaches.</p>\n<blockquote>\n<p>All example code is hosted in :</p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://github.com/agustinaliagac/GiphyTrends-AndroidExamples\">https://github.com/agustinaliagac/GiphyTrends-AndroidExamples</a></p>\n</blockquote>\n<h4>Building a REST Client in Android</h4>\n<p>REST ( Representational state transfer) has become a common way of\napplication-level communication between clients and servers over the network in\nthe last years. It’s fair to say that this is something that you probably have\ndone or will do in your next projects. For this tutorial the only API endpoint\nwe’ll be using is:\n<a href=\"https://github.com/Giphy/GiphyAPI#trending-gifs-endpoint\">https://github.com/Giphy/GiphyAPI#trending-gifs-endpoint</a>\nwith a simple HTTP GET request. The idea is to retrieve and display all trending\nGIFs from this endpoint. So what are some of the options that we have in Android\nto create a RESTful Client?</p>\n<h3>Implementing without extra libraries</h3>\n<p><a href=\"https://developer.android.com/reference/android/os/AsyncTask.html\">AsyncTasks</a>:\nThis option comes with Android’s core since API Level 3, and it’s available for\nus to use without adding any <em>gradle</em> dependency. AsyncTask allows us to perform\nbackground operations (e.g. network calls) in a different thread (preventing the\nmain thread to be blocked) and publish its results on the main thread. This\nmethod is easy to implement, but it comes with some difficulties like the fact\nthat you have to manage cancellation within our Component’s life-cycle. (read\nmore:\n<a href=\"http://blog.danlew.net/2014/06/21/the-hidden-pitfalls-of-asynctask/\">http://blog.danlew.net/2014/06/21/the-hidden-pitfalls-of-asynctask/</a>).\nWe will use AsyncTask to execute the network call through Java’s\n<strong>HttpURLConnection</strong> class.</p>\n<p>We’ll first create all common components for both approaches (UI, permissions,\nentities, etc.). Lets start by adding manifest permissions to our app including\n“<em>INTERNET</em>” and “<em>ACCESS<em>NETWORK</em>STATE</em>” permissions to allow us to retrieve\ndata from the network:</p>\n<h4>Setup the Main Activity to display the UI</h4>\n<h4>Create the AsyncTask</h4>\n<p>Notice that in this approach, we’re directly reading the API response through a\n<a href=\"http://docs.oracle.com/javase/7/docs/api/java/io/BufferedReader.html?is-external=true\">BufferedReader</a>.\nIf you’re not familiar with AsyncTask, the basic concept is that it will execute\nthe blocking task declared inside the “doInBackground()” method on another\nthread, and will later publish its results in “onPostExecute()” method on the UI\nthread. This is a cool feature, because it prevents blocking the UI while doing\na blocking operation. Another great feature is that it takes care of\nmulti-threading communication.</p>\n<p>When the task is complete, it will write the raw reponse in a simple TextView,\nfor the sake of simplicity. In “Part II”, we will take care of our UI so don’t\npanic !</p>\n<h4><strong>What about serialization?</strong></h4>\n<p>The server response comes serialized in JSON format (Javascript Object\nNotation), but we are only able to see a String representation after reading it\nwith <em>BufferedReader</em>. We need a way to map this JSON response into Java\nobjects, to be able to manipulate the data and do whatever we want with it. This\nprocess is called “<em>deserialization</em>”.</p>\n<p>In this approach, we have to take care of this process, as you can see in\n“<em>deserializeServiceResponse()</em>” method. We’re using “<em>org.json</em>” package\nclasses to get JSONObjects and JSONArrays , and later transforming this data\ninto our entity objects. The process is defined within a <em>try-catch</em> structure\nto avoid crashes from <em>JSONException</em> in runtime.</p>\n<p>Now lets imagine that “<em>Giphy</em>” decides to change this API endpoint, so the JSON\nresponse will be structured differently. Using this approach, it would imply\nthat we have to change our entity’s attributes as well as our deserialization\nmethod. This may not sound as a big deal, but if the API is constantly evolving\n(e.g during parallel backend and mobile development) it can be a really tedious\ntask to do.</p>\n<h3>Using Retrofit and Gson</h3>\n<p><a href=\"https://square.github.io/retrofit/\">Retrofit</a> is an open source library created\nby Square, that defines itself as it follows:</p>\n<blockquote>\n<p>“A type-safe HTTP client for Android and Java”.</p>\n</blockquote>\n<p>It aims simplicity, performing synchronous or asynchronous HTTP requests, which\nmeans you can make either “blocking” or “non-blocking” calls. If you want to use\nblocking calls, remember to implement it in a separate thread to avoid blocking\nthe app’s main thread, otherwise you’ll get a NetworkOnMainThreadException. I\nhaven’t done a performance/profiling test on the library, but I never had any\nkind of problems with that aspect. Let’s see how we can implement the same\n“AsyncTask” behavior but using this library.</p>\n<h4><strong>Adding the dependency in the app’s “build.gradle” file</strong></h4>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"> compile ‘com.squareup.retrofit2:retrofit:2.2.0’\n compile ‘com.squareup.retrofit2:converter-gson:2.2.0’</code></pre></div>\n<h4><strong>Defining the API endpoints</strong></h4>\n<p>You’ll need to create a Java interface to declare each endpoint that you’ll be\nusing of the API. Using annotations you can specify which HTTP method to use, as\nwell as the root-relative path. In this case, we’re only setting up one simple\nendpoint.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">public interface GiphyAPI {\n\n@GET(“gifs/trending”)\n  Call&lt;GiphyServiceResponse&gt; getTrends(@Query(“api_key”) String apiKey);\n}</code></pre></div>\n<p>The “<em>getTrends</em>()” method will return a Call object, that will later be used to\naccess the endpoint. Notice we’re setting the class type using Generics so the\nlibrary knows what kind of objects will manipulate. Retrofit allows us to pass\nthis method a @Query parameter, or a @Path variable to fully build the URL\nyou’re targeting. Also, if you’re performing a POST/PUT request, you can pass a\n@Body variable to tell the library how to build the request.</p>\n<h4>Building and executing the request</h4>\n<p>Finally, we have to build an execute the request. We’re using an asynchronous\ncall, getting the result in the callback method, and displaying it in a simple\nTextView, just like in the first approach.</p>\n<h4><strong>Serializers with Retrofit</strong></h4>\n<p>Retrofit uses “Converters” to serialize/deserialize objects. In our case, we’re\nusing “<a href=\"https://github.com/google/gson\">Gson</a>” as a serialization library, but\nyou could also pick another one like\n<a href=\"https://github.com/FasterXML/jackson\">Jackson</a> or\n<a href=\"https://github.com/square/moshi\">Moshi</a>.</p>\n<p>In contrast to the tedious process of using “<em>org.json</em>” classes to deserialize\nthe response, you can directly use your entity classes to tell Retrofit how the\nresponse is structured, and how it should be (de)serialized. The only thing you\nneed to take care of, is specifying the class attributes’s names when they are\ndifferent from the JSON response using the @SerializedName annotation.</p>\n<h3><strong>Conclusion</strong></h3>\n<p>With Retrofit, programming gets much more “declarative” and less “imperative”\nallowing you to focus on the data and what to do with it. I gained a lot of\nproductivity just by adopting Retrofit as my default REST Client interface. Some\nof the greatest things about it are:</p>\n<ul>\n<li>Retrofit gives you full control of asynchronous/synchronous requests, without\nthe need of cancelling tasks during life-cycle updates of your components.</li>\n<li>You can easily add “interceptors” to perform tasks like adding HTTP headers or\ndata to your request, or analyze responses globally.</li>\n<li>(De)serializing objects is quite faster to implement using a <em>Converter</em> with\n<em>Gson *compared to using “org.json” classes, and performance looks great. If you\nneed a very specific way to serialize an object, *Gson</em> still handles this\nsituation allowing you the register your own\n<a href=\"https://google.github.io/gson/apidocs/com/google/gson/TypeAdapter.html\">TypeAdapter</a>\n.</li>\n<li>The code looks way cleaner, just because you can define all endpoints (if you\nwant to) in a single Java Interface, but still manage each one of them\nseparately with the help of annotations and the tools Retrofit gives you.</li>\n</ul>\n<p>Hopefully, this tutorial helped you to know how Retrofit works, and how simple\nit is to build a full REST Client with it. In “Part II”, we’ll build our UI for\nthis app exploring “Android-core” options as well as libraries like “Butter\nknife”, and “Data-binding library”.</p>\n<p>Remember you can clone/fork the project here:\n<a href=\"https://github.com/agustinaliagac/GiphyTrends-AndroidExamples\">https://github.com/agustinaliagac/GiphyTrends-AndroidExamples</a></p>\n<p>And follow me on Github if you want:\n<a href=\"https://github.com/agustinaliagac\">https://github.com/agustinaliagac</a></p>\n<ul>\n<li><a href=\"https://medium.com/tag/android?source=post\">Android</a></li>\n<li><a href=\"https://medium.com/tag/android-app-development?source=post\">Android App\nDevelopment</a></li>\n<li><a href=\"https://medium.com/tag/retrofit2?source=post\">Retrofit2</a></li>\n<li><a href=\"https://medium.com/tag/retrofit?source=post\">Retrofit</a></li>\n<li><a href=\"https://medium.com/tag/rest-api?source=post\">Rest Api</a></li>\n</ul>\n<h3><a href=\"https://medium.com/@agustin.aliaga\">Agustin Aliaga</a></h3>\n<p>Software Developer</p>","frontmatter":{"title":"Common Android scenarios with and without third-party dependencies, part 1: REST Client","date":"February 27, 2017"}}},"pageContext":{"slug":"/common-android-scenarios-with-and-without-dependencies-part-1/","previous":null,"next":{"fields":{"slug":"/lessons-learned-on-mobile-ble-development/"},"frontmatter":{"title":"Lessons learned from building a mobile app with Bluetooth Low Energy support"}}}}